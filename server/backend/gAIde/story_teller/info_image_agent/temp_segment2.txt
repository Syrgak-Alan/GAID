        # Prefer the models.generate_content path
        response = client.models.generate_content(
            model="gemini-2.0-flash",
            contents=[prompt, image_part],
        )
        text: Optional[str] = getattr(response, "text", None)
        if not text:
            # Some SDK versions return candidates[0].content.parts[0].text
            text = None
            candidates = getattr(response, "candidates", None)
            if candidates:
                try:
                    parts = candidates[0].content.parts
                    if parts:
                        text = getattr(parts[0], "text", None) or str(parts[0])
                except Exception:
                    pass
        if not text:
            text = str(response)
        return text.strip()
    except Exception as e:
        raise RuntimeError(f"Gemini request failed: {e}") from e


# Helper to load/normalize nearby places JSON structure
def _load_nearby_places(data_or_path: Union[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
    data: Dict[str, Any]
    if isinstance(data_or_path, str):
        if not os.path.isfile(data_or_path):
            raise FileNotFoundError(f"Places JSON not found: {data_or_path}")
        with open(data_or_path, "r", encoding="utf-8") as f:
            data = json.load(f)
    else:
        data = data_or_path

    # Expected format: { "find_places_nearby_response": { "result": [ {name, latitude, longitude, address?, distance_m?}, ... ] } }
    results = (
        data.get("find_places_nearby_response", {}).get("result")
        if isinstance(data, dict)
        else None
    )
    if not isinstance(results, list):
        raise ValueError("Invalid places JSON: expected find_places_nearby_response.result list")

    # Normalize and filter minimal fields
    cleaned: List[Dict[str, Any]] = []
    for item in results:
        if not isinstance(item, dict):
            continue
        name = item.get("name")
        lat = item.get("latitude")
        lon = item.get("longitude")
        if not name or lat is None or lon is None:
            continue
        cleaned.append({
            "name": str(name),
            "latitude": float(lat),
            "longitude": float(lon),
            "address": item.get("address"),
            "distance_m": item.get("distance_m"),
        })

    # Sort by distance if present
    cleaned.sort(key=lambda x: (float(x["distance_m"]) if x.get("distance_m") is not None else float("inf")))
    return cleaned


def recognize_showplace_with_nearby(
    image_path: str,
    places_json: Union[str, Dict[str, Any]],
    *,
    locale: str = "en",
    max_places: int = 30,
) -> str:
    """
    Recognize a landmark in an image with additional context of nearby showplaces
    to disambiguate lookalikes by location (e.g., replicas).

    Inputs:
      - image_path: local path to the image file
      - places_json: path to a JSON file or the parsed dict with schema:
            {"find_places_nearby_response": {"result": [ {name, latitude, longitude, address?, distance_m?}, ... ]}}
      - locale: response language (default "en")
      - max_places: maximum number of nearby places to provide as context

    Returns:
      - String response from Gemini, ideally naming the most likely showplace among the provided nearby options,
        and indicating reasoning/coordinates.
    """

    if not image_path:
        raise ValueError("image_path is required")
    if not os.path.isfile(image_path):
        raise FileNotFoundError(f"Image not found: {image_path}")

    nearby = _load_nearby_places(places_json)
    if not nearby:
        # Fallback to vision-only if no usable places
        return recognize_showplace(image_path=image_path, locale=locale)

    api_key = os.environ.get("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError(
            "GOOGLE_API_KEY is not set. Add it to environment or multi_tool_agent/.env"
        )

    try:
        from google import genai
        from google.genai import types as genai_types
    except Exception as e:
        raise RuntimeError(
            "google-genai is required. Install with: pip install google-genai"
        ) from e

    client = genai.Client(api_key=api_key)

    with open(image_path, "rb") as f:
        image_bytes = f.read()
    mime_type, _ = mimetypes.guess_type(image_path)
    if mime_type is None:
        mime_type = "image/jpeg"

    try:
        image_part = genai_types.Part.from_bytes(data=image_bytes, mime_type=mime_type)
    except Exception as e:
        raise RuntimeError("Failed to create image part for Gemini request") from e

    # Trim and serialize nearby places for context
    nearby_trimmed = nearby[: max_places if max_places > 0 else len(nearby)]
    nearby_json = json.dumps(nearby_trimmed, ensure_ascii=False)

    system_prompt = (
        "You are a landmark recognition assistant for travelers. "
        "You MUST identify the landmark in the provided image, BUT when a list of nearby showplaces is provided, "
        "you should disambiguate using those options, preferring a match from the list that best fits the image and location. "
        "If the image looks like a famous landmark with replicas elsewhere, choose the one consistent with the provided nearby list. "
        "Only pick from the provided nearby list when confident; otherwise provide your best vision-only guess and say you are uncertain."
    )

    task_prompt = (
        f"Use language: {locale}.\n"
        "Nearby showplaces (JSON, sorted by distance):\n"
        f"{nearby_json}\n\n"
        "Instructions:\n"
        "- First, recognize the landmark from the image.\n"
        "- Then, compare with the provided nearby showplaces.\n"
        "- If one of the nearby names matches or strongly corresponds to the image, select it.\n"
        "- If none match, respond with your best guess and note uncertainty.\n"
        "- Respond in a single concise line: '<Landmark Name> - <City/Country if known>' and optionally a short note if disambiguation was used."
    )

    try:
        response = client.models.generate_content(
            model="gemini-2.0-flash",
            contents=[system_prompt, task_prompt, image_part],
        )
        text: Optional[str] = getattr(response, "text", None)
        if not text:
            candidates = getattr(response, "candidates", None)
            if candidates:
                try:
                    parts = candidates[0].content.parts
                    if parts:
                        text = getattr(parts[0], "text", None) or str(parts[0])
                except Exception:
                    pass
        if not text:
            text = str(response)
        return text.strip()
    except Exception as e:
        raise RuntimeError(f"Gemini request with nearby places failed: {e}") from e

# Instantiate the agent and register the tool function so root_agent can use it.
root_agent: Optional[Any] = None
if _GoogleADKAgent is not None:
    root_agent = _GoogleADKAgent(
        name="image_recognition_agent",
        model="gemini-2.0-flash",
        description="An agent that can recognize landmarks/showplaces in images using Gemini API",
        instruction=(
            "You are an image recognition agent that identifies landmarks and showplaces in traveler photos using the Gemini API. "
            "When possible, use nearby showplaces JSON context to disambiguate lookalikes by location. "
            "If nearby places are provided, prefer returning a match from that list that fits the image."
        ),
        tools=[recognize_showplace, recognize_showplace_with_nearby],  # Register tools
    )


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Recognize landmark/showplace from an image using Gemini 2.0 Flash",
    )
    parser.add_argument("image", help="Path to the image file (jpg/png/webp/etc.)")
    parser.add_argument("--places", help="Path to nearby showplaces JSON (exp.json format)")
    parser.add_argument("--locale", default="en", help="Response language (e.g., en, fr, es)")
    args = parser.parse_args()

    try:
        if args.places:
            result = recognize_showplace_with_nearby(args.image, args.places, locale=args.locale)
        else:
            result = recognize_showplace(args.image, locale=args.locale)
        print(result)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
